# Git团队协作基础

### 核心理念转变：从“我的仓库”到“我们的项目”

在独自开发时，`main`分支是你的个人工作区，提交（commit）是你自己的存档点。但在团队中，这一切都变了：

- **远程仓库是“唯一真相来源” (Single Source of Truth)**：`origin/main`不再仅仅是你的备份，它是整个团队公认的、最权威、最稳定的代码版本。你的所有工作都应以此为基础，并最终贡献于此。
- **分支是“安全隔离的实验室”**：在团队项目中，**绝对不要直接向`main`或`develop`等公共分支提交代码**。任何新的开发工作都必须在自己的分支（Feature Branch）上进行。这就像在主建筑旁搭建一个独立的脚手架，你可以在上面随意施工，而不会影响主建筑的结构和安全。
- **提交和拉取请求是“团队沟通”**：你的每一次提交（Commit）和拉取请求（Pull Request）都是在向团队成员沟通：“我做了什么，为什么这么做”。清晰的提交信息和PR描述是高效协作的关键，而不只是简单的操作记录。



### 经典 Git 协作工作流的设计哲学与实践

选择哪种工作流，取决于项目的发布频率和团队规模。理解其背后的设计思想，比死记硬背命令更重要。

#### 1. GitHub Flow：拥抱敏捷与持续交付

**设计哲学：简单、快速、始终可部署。**

GitHub Flow是为那些需要频繁发布、快速迭代的团队（尤其是Web应用）设计的。它的核心思想是**最大程度地简化流程，确保`main`分支在任何时刻都是稳定且可以直接部署到生产环境的**。它通过强制所有变更都经过Pull Request来保证这一点。

**为什么这样设计？**

- **保证主干稳定**：通过禁止直接推送到`main`分支，从根本上杜绝了未经测试或未被审查的代码污染生产环境的可能性。`main`分支的每一次更新都是经过团队确认的、高质量的合并。
- **强化代码审查 (Code Review)**：Pull Request是其灵魂。它不仅仅是合并代码的请求，更是一个代码审查、知识分享和团队讨论的平台。在这里，资深开发者可以指导新手，团队可以就最佳实践达成共识，从而提升整体代码质量。
- **支持持续集成/持续部署 (CI/CD)**：由于`main`分支始终可部署，可以非常容易地与自动化工具集成。每一次向`main`的合并都可以自动触发测试、构建和部署流程，实现真正的持续交付。

**协作实践复盘：**

1. **从`main`拉取最新代码**：`git checkout main` -> `git pull origin main`。确保你的“实验室”是基于最新的蓝图搭建的。
2. **创建你的特性分支**：`git checkout -b feature/add-user-profile`。给分支起一个能清晰描述其功能的名称。
3. **本地开发与提交**：在你的分支上安心工作。进行**原子化提交**，即每个提交只做一件事，并写好Commit Message。
4. **发起Pull Request (PR)**：当你完成开发或需要反馈时，`git push -u origin feature/add-user-profile`，然后在GitHub上创建指向`main`的PR。在PR描述中清晰说明你解决了什么问题，如何解决的，以及需要审查者注意什么。
5. **响应审查与讨论**：根据团队成员的反馈修改代码，并直接在你的特性分支上提交和推送。GitHub会自动更新PR。
6. **合并与清理**：PR被批准后，由负责人（或你自己）在GitHub上点击“Merge”按钮。合并后，为了保持仓库整洁，应删除该特性分支。

#### 2. Git Flow：应对复杂的、计划性发布

**设计哲学：结构化、职责分离、版本发布控制。**

如果你的项目有明确的版本发布计划（如v1.0, v1.1, v2.0），并且需要同时维护已发布的旧版本（例如为其提供安全更新），那么Git Flow提供的严格结构就是为你而设的。它的核心思想是**通过设立不同职责的分支，将“正在开发的功能”和“已发布的稳定代码”进行彻底隔离**。

**为什么这样设计？**

- **双主干隔离风险**：
  - `main`分支**只用于存放发布版**。它像一个产品的“历史陈列馆”，每一个节点（Tag）都是一个公开发布的、经过完整测试的稳定版本。
  - `develop`分支是**所有新功能的集散地**。它代表了下一个版本“可能”会包含的所有功能。日常开发都在这里汇集，允许它处于一个相对不稳定的“开发中”状态。这种隔离确保了无论`develop`分支如何“混乱”，`main`分支永远是可靠的。
- **专门的分支应对专门的任务**：
  - **Release Branches (发布分支)**：当`develop`分支的功能足够发布一个新版本时，就拉出一个`release`分支。这个分支的设计目的是**“冻结新功能”**。在此之上，团队只进行Bug修复、文档完善等与发布相关的收尾工作，而`develop`分支可以继续向前开发下下个版本的新功能，两者互不干扰。
  - **Hotfix Branches (热修复分支)**：这是处理线上紧急问题的“绿色通道”。当已发布的`main`分支版本出现严重Bug时，可以直接从`main`拉出`hotfix`分支进行快速修复。修复后，**必须同时合并回`main`和`develop`**，确保修复内容既能立刻更新到线上，又不会在下一个版本发布时丢失。

**协作实践复盘：**

- **日常开发**：开发者从`develop`拉取最新代码，创建自己的`feature`分支，完成后合并回`develop`。
- **准备发布**：发布负责人从`develop`创建`release/v1.1.0`分支。QA团队在此分支上进行测试。
- **修复发布前Bug**：测试发现的Bug，直接在`release`分支上修复并提交。
- **正式发布**：`release`分支稳定后，将其**同时合并到`main`分支（并打上v1.1.0的Tag）和`develop`分支**。
- **处理线上紧急Bug**：从`main`创建`hotfix/v1.0.1`分支，修复后，**同时合并回`main`（并打上v1.0.1的Tag）和`develop`分支**。



### **适用于小团队的轻量化协作工作流**

对于成员不多、互相信任、追求开发效率的小团队，尤其是学生项目组，一套完整的 `Git Flow` 或 `GitHub Flow` 流程（特别是强制的Pull Request和代码审查）可能会显得过于繁重。

以下介绍一种更简单、更直接的协作模式，我们称之为 **“共享 `main` 与特性分支”** 工作流。

#### **核心理念：信任与频繁同步**

此工作流的设计哲学基于两个基石：

1. **团队信任**：相信每一位成员都有能力和责任心来维护 `main` 分支的相对稳定。我们省去强制的代码审查，以换取更高的开发效率。
2. **频繁同步**：每个成员在将自己的代码合入主干前，都有责任主动与主干的最新代码保持同步。这可以最大程度地减少合并时的冲突和困难，是整个工作流顺畅运转的关键。

------

#### **核心协作周期：以“周会合并”为例**

假设你们团队每周开一次组会，需要在会上将大家的工作集成起来看效果。下面是完整的分步操作和关键命令详解。

##### **步骤一：开始新工作（例如周一） - 同步主干**

在开始任何新的开发任务之前，**必须**确保你的本地 `main` 分支是最新版本。这就像每天动工前，要先拿到最新的工程蓝图。

**▶︎ 关键命令：**

```sh
# 1. 切换到你的本地 main 分支
git checkout main

# 2. 从远程仓库（origin）拉取 main 分支的最新更新
git pull origin main
```

**命令详解：**

- `git checkout main`：这个命令确保你当前的操作对象是本地的 `main` 分支。只有先切换到它，`pull` 操作才能正确地更新它。
- `git pull origin main`：这是整个工作流中最重要的同步命令之一。它实际上是两个命令的组合：
  - `git fetch origin`：从远程仓库（通常名为 `origin`）下载所有分支的最新信息和提交历史，但**不会**修改你本地的任何分支。它只是让你“看一眼”远程仓库的最新情况。
  - `git merge origin/main`：将刚刚 `fetch` 下来的远程 `main` 分支（现在在你本地被称为 `origin/main`）合并到你当前所在的本地 `main` 分支。

执行完这一步，你的本地 `main` 分支就和GitHub上的 `main` 分支完全一致了。

##### **步骤二：专注开发 - 创建并使用特性分支**

这是团队协作的黄金法则：**永远不要在 `main` 分支上直接进行开发和提交！** 任何新功能、Bug修复都应该在一个独立的分支上进行，以保证 `main` 分支的整洁和安全。

**▶︎ 关键命令：**

```sh
# 从当前（最新的）main分支创建并立即切换到一个新分支
git checkout -b feature/user-login-zhangsan
```

**命令详解：**

- `git checkout -b <新分支名>`：这是一个便捷的复合命令，它完成了两件事：
  1. `git branch feature/user-login-zhangsan`：创建一个名为 `feature/user-login-zhangsan` 的新分支。一个好的命名习惯（如 `类型/功能-开发者`）能让团队一目了然。
  2. `git checkout feature/user-login-zhangsan`：立即切换到这个新创建的分支上。

现在，你就在属于自己的“沙盒”里了。在这里，你可以自由地进行编码、修改、提交，完全不会影响到其他任何人和 `main` 分支。

```sh
# ...安心地编写你的代码...
git add .
git commit -m "完成用户登录界面基础布局"
# ...继续开发和提交...
```

##### **步骤三：准备合并（例如周五组会前） - 最关键的同步步骤**

这是整个流程中最能体现协作技巧的一步。在你要将自己的成果合并回 `main` 之前，必须先将 `main` 分支在这期间发生的新变化同步到你的特性分支上。

**▶︎ 关键命令：**

```sh
# 1. 先确保你的本地 main 分支是最新版本（以防有队友在你之前合并了代码）
git checkout main
git pull origin main

# 2. 切换回你自己的特性分支
git checkout feature/user-login-zhangsan

# 3. 将你的分支“变基”到最新的 main 分支上
git rebase main
```

**命令详解：**

- `git rebase main`：**这是此工作流的精髓所在**。`rebase`（变基）做了什么？
  - 它会找到你当前特性分支和 `main` 分支的共同祖先。
  - 然后，它把你从共同祖先之后的所有提交**逐一地**、**按顺序地**在最新的 `main` 分支的顶端重新应用一遍。
- **为什么要用 `rebase` 而不是 `merge`？**
  - **保持历史清爽**：`rebase` 会创造一个非常干净、线性的提交历史。从图上看，你的特性分支就像是“刚刚”从最新的 `main` 分支拉出来开发的一样，没有多余的、难看的“Merge”信息。
  - **冲突前置解决**：如果在 `rebase` 过程中，你的某次提交和 `main` 的新变更冲突了，Git会暂停，让你**在自己的分支上**解决冲突。这意味着**冲突的责任由引入该功能的人自己承担**，而不是在合并到 `main` 时才暴露给全队，污染主干。

##### **步骤四：执行合并 - 将你的成果贡献给主干**

当你成功完成了 `rebase` 并且解决了所有潜在冲突后，合并操作就会变得异常简单和安全。

**▶︎ 关键命令：**

```sh
# 1. 切换回 main 分支，准备接收你的成果
git checkout main

# 2. 将你已经“变基”过的特性分支合并进来
git merge feature/user-login-zhangsan

# 3. 将更新后的 main 分支推送到远程仓库，与团队共享
git push origin main
```

**命令详解：**

- `git merge feature/user-login-zhangsan`：因为你之前已经做了 `rebase`，此时的 `main` 分支相对于你的特性分支只是“落后”了几个版本。因此，这次合并会是一个 **“快进（Fast-forward）”** 合并。Git不会创建新的合并提交，只是简单地将 `main` 分支的指针向前移动到你的特性分支的最新位置，干净利落。
- `git push origin main`：将你本地的、已经包含了新功能的 `main` 分支的更新推送到GitHub上，这样其他团队成员就可以在下一次 `pull` 时获取到你的工作成果了。

至此，一个完整的协作周期就完成了。其他同学也按此流程操作，你们就能高效、有序地将工作成果汇集到一起。



## Git 命令详解

## Git Merge vs. Rebase 分支合并

简单来说，两者都是将一个分支的变更融入另一个分支的工具，但它们实现这一目标的哲学和方式完全不同。**`merge` 的目标是“忠实记录”，而 `rebase` 的目标是“整洁历史”**。

### git merge (合并) 🤝

`merge` 是一种非破坏性操作，它会保留分支开发过程的全部历史。

#### **工作原理**

当你在 `main` 分支上执行 `git merge feature/login` 时，Git 会：

1. **寻找共同祖先**：找到 `main` 分支和 `feature/login` 分支最近的一个共同祖先提交 (common ancestor)。
2. **差异整合**：比较两个分支自共同祖先以来的所有变更。
3. **创建合并提交 (Merge Commit)**：生成一个**全新的、特殊的提交**，这个提交被称为“合并提交”。这个合并提交有两个父提交 (parent commits)：一个是 `main` 分支的最新提交，另一个是 `feature/login` 分支的最新提交。它将两个分支的变更内容整合在一起。

最终的提交历史图谱看起来***<u>像两条河汇合</u>***一样，清晰地记录了分支的创建、开发和最终汇入主干的全过程。

#### **冲突解决的时机与方式**

- **时机**：冲突在执行 `git merge` 命令的**最后阶段**才会被检测到。Git 会尝试自动合并所有文件的变更，只有当两个分支修改了同一个文件的同一区域时，才会宣告失败并等待你介入。
- **解决方式**：你需要**一次性地解决所有文件的所有冲突**。Git 会在冲突文件中用特殊标记（`<<<<<<<`, `=======`, `>>>>>>>`）标出所有冲突点。你必须手动编辑这些文件，决定最终保留哪些内容，然后将所有修改过的文件 `git add`，最后执行 `git commit` 来完成这个包含所有解决方案的、唯一的合并提交。整个解决过程都发生在这次合并操作的终点。

#### **一般使用场景**

- **合并公共分支**：这是最主要、最安全的场景。例如，将一个已经完成并通过审查的特性分支合并到 `develop` 或 `main` 这样的公共分支时，**应当使用 `merge`**。
- **团队协作**：当团队成员需要将远程主干的更新同步到自己的特性分支时，使用 `merge` 也是一种安全的选择，因为它不会改动任何已有的提交历史。

#### **优缺点**

- **优点**：
  - **真实且可追溯**：完整地保留了项目的开发历史，包括每一次分支和合并，忠实地记录了“当时发生了什么”。
  - **<u>安全</u>**：不会修改任何已有的提交记录，只会在历史的顶端添加新的合并提交。
- **缺点**：
  - **历史冗余**：如果项目分支非常多且合并频繁，提交历史会变得非常复杂，形成所谓的“意大利面条”式的图谱，难以阅读和审计。
  - **产生额外的合并提交**：每次合并都会创建一个 `Merge commit`，这在某些追求极简历史的团队看来是一种不必要的“噪音”。

---

### git rebase (变基) 🧹

`rebase` 是一种“历史整理”工具，它通过“重新设置基点”的方式，将你的提交历史嫁接到另一个分支的顶端，从而创造出一条线性的、整洁的提交历史。

#### **工作原理**

当你在 `feature/login` 分支上执行 `git rebase main` 时，Git 会：

1. **寻找共同祖先**：同样，先找到 `feature/login` 和 `main` 的共同祖先。
2. **暂存你的提交**：Git 会将 `feature/login` 分支上自共同祖先以来的所有提交（例如 C3, C4）“暂存”起来，就像暂时拔起一棵树。
3. **移动分支指针**：将 `feature/login` 分支的指针移动到 `main` 分支的最新提交（例如 C5）上。
4. **重新应用提交**：将刚才暂存的提交（C3, C4）**逐一地、按顺序地**在新的基点（C5）之上重新应用一遍，生成**全新的提交**（C3', C4'）。这些新提交的内容和原来一样，但因为它们的父提交变了，所以它们的哈希值 (SHA-1) 是全新的。像是把 `feature/login` 分支直接<u>***嫁接***</u>到了`main`分支上。

最终的提交历史图谱看起来就像你的特性分支**从一开始就是基于最新的 `main` 分支开发的一样**，非常干净利落。

#### **冲突解决的时机与方式**

- **时机**：冲突在 `rebase` 过程中**随时可能发生**。因为 Git 是在逐个应用你的旧提交，所以每应用一个提交，都可能与新的基点（`main` 分支）产生冲突。
- **解决方式**：你需要**一个一个地解决冲突**。当 Git 在应用某个提交（比如 C3）时发现冲突，`rebase` 过程会暂停。你需要像解决 `merge` 冲突一样编辑文件，然后执行 `git add .` 将其标记为已解决。但接下来，你不是执行 `commit`，而是执行 `git rebase --continue`，告诉 Git：“这个提交的冲突我解决了，请继续应用下一个提交”。如果中途想放弃，可以使用 `git rebase --abort`。这个“解决 -> 继续”的循环会一直持续，直到你所有的提交都成功应用完毕。

#### **一般使用场景**

- **个人分支清理**：在将你的本地特性分支推送到远程或发起 Pull Request 之前，使用 `rebase` 同步主干的最新代码。这能让你自己先解决掉所有冲突，并提交一个干净的历史给团队审查。
- **同步远程更新**：使用 `git pull --rebase`。这个命令会先 `fetch` 远程更新，然后用 `rebase` 的方式将你的本地提交应用到最新远程版本的顶端，避免了 `git pull` 默认产生的无意义的“Merge”提交。

#### **优缺点**

- **优点**：
  - **历史线性整洁**：最终的提交历史是一条直线，非常清晰，易于阅读和理解。
  - **没有无意义的合并提交**：让每一次提交都显得更有价值。
- **缺点**：
  - **改写历史**：`rebase` 会创建新的提交来取代旧的，这是一种破坏性操作。
  - **潜在风险**：如果滥用在公共分支上，会给团队其他成员带来巨大的麻烦。

#### **⚠️Rebase 的黄金法则 **

最后，也是最重要的一点：**永远不要在一个已经被推送到远程并被团队共享的公共分支（如 `main`, `develop`）上执行 `git rebase`。**

**原因**：因为 `rebase` 会用全新的提交取代旧的提交。如果你重写了一个大家都依赖的公共分支的历史，那么当其他成员试图 `pull` 更新时，他们的本地历史和远程历史就会产生严重分歧。Git 会认为这是两个完全不同的历史，从而导致巨大的混乱和需要手动修复的大量重复提交。

**简单记**：`rebase` 是你用来**整理自己“私有”工作**的工具，而 `merge` 是用来**整合团队“公共”成果**的工具。

---

### **区别总结**

| **特性**     | **git merge**                      | **git rebase**                         |
| ------------ | ---------------------------------- | -------------------------------------- |
| **历史记录** | 📜 **保留**真实、完整的历史         | ✍️ **重写**历史，使其变得线性           |
| **提交图谱** | 呈**汇合状**，有分支和合并节点     | 呈**线性**，一条直线                   |
| **合并提交** | ✅ **会**创建一个新的合并提交       | ❌ **不会**产生额外的合并提交           |
| **冲突解决** | 在最终合并时**一次性**解决所有冲突 | 在变基过程中**逐个**解决每个提交的冲突 |
| **核心理念** | 记录“**发生了什么**”               | 整理成“**故事应该怎么讲**”             |

---

### **合并后如何处理特性分支？**

当你的特性分支（如 `feature/login`）已经被成功合并到主干（如 `main` 或 `develop`）之后，这个特性分支的历史使命就已经完成了。它所包含的所有变更现在都已经是主干的一部分。

- **所处状态**：它仍然存在于你的本地仓库和远程仓库中，但它已经是一个“过时”的分支。从它分叉出去的那个点，到它被合并前的所有提交，现在都已经可以通过主干的历史访问到。
- **一般处理方式**：**删除它**。这是一个非常好的习惯，可以保持你的仓库干净整洁，避免分支泛滥。

**▶︎ 关键命令：**

```
# 1. 删除本地的特性分支
# -d 选项是 --delete 的缩写，它会检查该分支是否已被合并，如果未合并则会报错，防止误删。
git branch -d feature/login

# 2. 删除远程仓库中的特性分支
git push origin --delete feature/login
```

**为什么这么做？**

- **保持整洁**：一个项目进行久了，如果不及时清理，会积累成百上千个已合并的分支，无论是本地还是远程，都会给查找和管理带来巨大困难。
- **避免混淆**：防止自己或其他团队成员不小心又切换到这个已经过时的分支上继续开发，从而引发不必要的问题。
- **单一职责**：一个分支只用来完成一个任务，任务完成，分支的生命周期就应该结束。

如果未来需要基于这个功能做修改或修复，正确的做法是**从当前最新的主干重新拉出一个新的分支**，而不是在旧的、已合并的分支上继续工作。



## 深度辨析 Git Rebase

在之前的讨论中，我们提到了在团队协作中可以使用 `rebase` 来保持 `main` 分支历史的整洁。但 `rebase` 的一个核心概念——“重写历史”——常常会引起困惑。这份笔记旨在深入阐明 `rebase` 的工作原理，解释它为何是“重写”而非“续写”，并展示它如何与 `merge` 配合，完成一次干净、线性的代码合并。

#### 一、“重写历史”的真正含义

要理解“重写”，我们必须先知道 Git 如何识别一次提交（Commit）。每个提交都有一个独一无二的 SHA-1 哈希值作为其“身份证号”。这个哈希值由提交的内容、作者信息、提交信息以及至关重要的**父提交（Parent Commit）**共同决定。**只要其中任何一项信息改变，哈希值就会完全不同。**

`rebase` 的核心操作正是改变了提交的“父提交”，从而创造了全新的提交来取代旧的提交。

让我们通过您最关注的那个例子来完整地看一下这个过程：

**1. 初始状态**

假设你的 `feature` 分支是从 `main` 分支的 C1 提交上创建的，之后你开发了 C3 和 C4 两个新提交。与此同时，你的队友在 `main` 分支上合并了新的提交 C2。

```
              C3 --- C4  <-- feature  (C3的父节点是C1)
             /
A --- B --- C1 --- C2  <-- main
```

此时，`feature` 分支的历史是基于 C1 的。

**2. Rebase 操作：重写特性分支**

现在，你在 `feature` 分支上执行 `git rebase main`。Git 会：

1. 找到 `feature` 分支上独有的提交（C3, C4）。
2. 将 `feature` 分支的“基底”从 C1 移动到 `main` 的最新位置 C2。
3. **依次**将 C3 和 C4 的**代码变更**在 C2 之上重新应用一遍，创造出**全新的提交 C3' 和 C4'**。

分析一下新的 **C3'** 提交：

- 它的代码变更内容和 C3 相同。
- 但是，它的**父提交**不再是 C1，而是 **C2**！

由于父提交变了，C3' 的哈希值会和 C3 完全不同。同理，C4' 的父提交是 C3'，其哈希值也和 C4 完全不同。

**Rebase 之后，`feature` 分支的历史图谱变为：**

```
                     C3'--- C4' <-- feature (C3'的父节点是C2)
                    /
A --- B --- C1 --- C2  <-- main
```

结论：

rebase 并没有修改 main 分支。它重写了 feature 分支的历史，用一组拥有全新身份（哈希值）的提交（C3', C4'）替换了旧的提交（C3, C4）。这就是“重写历史”的本质。

#### 二、Rebase 与 Merge 的双重奏：一次完整的线性合并

`rebase` 只是准备阶段，它本身并不会将代码合入 `main`。它为后续一次干净的 `merge` 操作铺平了道路。

**1. 准备阶段：`rebase` (已完成)**

如上所述，`feature` 分支已经被完美地“嫁接”到了 `main` 分支的顶端。

**2. 收尾阶段：`merge` (续写 Main 分支)**

现在，我们切换回 `main` 分支，执行合并操作：

```
git checkout main
git merge feature
```

此时，Git 会发现 `main` 分支当前所在的提交 C2，是 `feature` 分支历史路径上的一个**直接祖先**。换句话说，`feature` 分支的历史完全包含了 `main` 分支的全部历史，并且只是在其基础上向前延伸。

在这种情况下，Git 不需要创建一个新的“合并提交”来解决分叉。它只需要执行一次 **“快进”（Fast-forward）** 操作：简单地将 `main` 分支的指针向前移动，直接指向 `feature` 分支的最新提交 C4' 即可。

**最终，`main` 分支的历史图谱变为：**

```
A --- B --- C1 --- C2 --- C3'--- C4'  <-- main, feature
```

结论：

从 main 分支的视角来看，它的历史没有经历任何“分叉”与“汇合”，只是在原有的基础上，平滑地、线性地延续了一段新的历史。

#### 总结

现在我们可以清晰地总结这个流程：

1. **`rebase` 是准备工作**：它通过**重写**特性分支的历史，来确保该分支是基于最新的主干代码开发的。
2. **`merge` 是收尾工作**：在 `rebase` 之后，`merge` 操作得以用一种极其简洁的“快进”方式，将特性分支的成果无缝地**续写**到 `main` 分支的历史中。

正是因为 `rebase` 先在特性分支上完成了“重写”的整理，才换来了后续 `main` 分支能够轻松“续写”的整洁结果。这个组合技是保持项目历史清晰、线性的强大工具。