# HTTP/2 笔记

## 1. 基本概念

- **Frame（帧）**
   HTTP/2的最小传输单位。每个帧都有固定的9字节帧头，其中包含：
  - 长度（3字节）：帧负载的字节数
  - 类型（1字节）：例如HEADERS、DATA、CONTINUATION等
  - 标志（1字节）：描述帧的属性，如END_STREAM、END_HEADERS等
  - 流标识符（4字节）：标识该帧所属的stream
- **Stream（流）**
   一个逻辑通道，用于承载一个完整的HTTP请求-响应交互。每个stream由唯一的stream ID标识。
  - 客户端主动创建的stream使用奇数ID
  - 服务器主动创建（如Server Push）的stream使用偶数ID
     流的作用包括实现多路复用和流量控制。
- **Message（消息）**
   HTTP请求或响应的逻辑单位。一个HTTP/2 message由：
  - 一个HEADERS帧（包含请求或响应头部）
  - 0个或多个DATA帧（包含请求或响应体）
     组成。每个stream内对应一条完整的请求和一条完整的响应消息。

## 2. 多路复用与帧交错传输

- **多路复用**
   HTTP/2允许在单一TCP连接上并发传输多个HTTP请求/响应，每个请求-响应对通过不同的stream来标识。
- **帧交错传输**
   各个stream内的帧可以交错发送。由于每个帧都带有stream ID，接收端能根据ID将不同stream的帧重新组装成各自的message。

## 3. HTTP/2与HTTP/1.1的对比

- **协议格式**
  - HTTP/1.1：基于文本，报文的请求行、头部以及分块传输编码（Chunked Transfer Encoding）都是文本格式，便于调试，但存在解析效率较低、队头阻塞问题。
  - HTTP/2：使用二进制帧格式，所有传输的数据（包括头部和body）均以二进制形式封装，带来更高效的解析和扩展性。
- **传输方式**
  - HTTP/1.1：一次请求-响应过程中通常按整个报文传输，动态内容可能使用分块传输编码。
  - HTTP/2：将报文拆分成多个帧进行传输，帧作为逻辑单元传输，接收端根据stream ID和帧结构重组完整消息。
- **多路复用**
  - HTTP/1.1的Pipeline只能在单个TCP连接内串行处理，存在队头阻塞问题。
  - HTTP/2在一个TCP连接上真正实现了多路复用，不同stream的帧可以交错发送，达到高并发传输效果。

## 4. 编码与分块

- **HTTP/1.1分块传输编码**
  - 服务器在无法预知完整内容长度时采用Chunked Transfer Encoding。
  - 每个chunk以文本形式描述长度（十六进制数字），后跟数据和换行符，然后一个大小为0的chunk标识结束。
- **HTTP/2二进制帧传输**
  - HTTP/2采用二进制分帧，将所有数据拆分为结构化的、固定格式的帧。
  - 这是一种应用层逻辑上的划分，与TCP分段无关。TCP仍然根据MSS等参数对HTTP/2帧进行分段传输。
- **分层设计**
  - HTTP/2帧是应用层结构，旨在实现流量控制、多路复用和优先级管理；而TCP分段是物理传输层对数据流的分割。两者各司其职，HTTP/2不需要按照TCP的分段来设计帧大小。

## 5. Server Push 与 Stream ID规则

- **Server Push**
   服务器可以主动推送资源，其创建的stream ID必须为偶数。
- **请求-响应对**
   客户端发起请求时创建stream（使用奇数ID），响应包括该stream内的HEADERS和DATA帧。
- **区分原则**
   每个stream只承载一条完整的请求及其对应的响应，避免混淆；各个stream可以并发交错传输，接收端根据stream ID组装成各自的message。

## 6. 关键点总结

- 一个HTTP请求在HTTP/2中只会有一个对应的响应，每个stream承载一个完整的请求-响应交互。
- HTTP/2的并发依赖于在单一TCP连接内按流（stream）分割和交错传输多个帧，每个帧通过stream ID标识归属。
- HTTP/2的帧结构化和二进制格式设计使得数据传输更高效，支持多路复用和流量控制，而这与TCP的分段传输互不干扰，各自处理不同层次的问题。

这份笔记涵盖了HTTP/2的核心架构、流、消息、帧等概念及其与HTTP/1.1的主要区别，有助于你在面试中条理清晰地回答相关问题。





# HTTPS

## 四次握手的必要性

虽然我们通常说 **TCP 三次握手**，但在 **TLS 建立安全连接的过程中**，确实可以被理解为类似“四次握手”的结构。下面我们明确一下这个“四次”的含义，特别是**“第四次握手是否必要”**的问题。

### 一、TLS（以 TLS 1.2 为例）的“握手流程”

下面是 TLS 1.2 的典型握手步骤，可以大致归纳为“类四次握手”：

1. **ClientHello（客户端发起）**
   - 包括支持的协议版本、随机数、加密套件列表等
2. **ServerHello + Certificate + ServerKeyExchange + ServerHelloDone（服务器响应）**
   - 确定加密参数，发送证书（含公钥）
3. **ClientKeyExchange + ChangeCipherSpec + Finished（客户端发送）**
   - 客户端生成对称加密密钥（Pre-Master Secret），加密后发给服务器
   - 发送ChangeCipherSpec：表示后续通信启用加密
   - 发送Finished：用密钥加密的摘要，验证握手是否成功
4. **ChangeCipherSpec + Finished（服务器确认）**
   - 服务器也开始使用加密通信
   - 发送Finished：表示握手完成

### 二、为什么是“四次”而不是“两次”或“三次”？

可以理解为“两次往返 RTT”：

- 第一次 RTT：客户端 -> 服务端
  - ClientHello
  - ServerHello + Certificate + ServerKeyExchange + ServerHelloDone
- 第二次 RTT：客户端 -> 服务端（ClientKeyExchange） -> 客户端
  - 客户端发送 key，表示开始加密通信
  - 服务器也确认，握手完成

这“第二个RTT”包含两个方向的消息，合起来就是 **“第四次握手”**。

### 三、第四次握手（Server Finished）是否必要？

**非常必要。原因如下：**

1. ✅ **安全性校验**
   - Server Finished 包含对之前所有握手内容的加密摘要（HMAC），客户端必须验证它来确认中间过程没有被篡改。
2. ✅ **确保服务器也完成了加密设置**
   - 如果没有 Server Finished，客户端无法确定服务器是否成功切换到了加密通信。
3. ✅ **防止中间人攻击**
   - 若跳过 Server Finished，中间人可能劫持后续通信而不被发现。

### 四、如果没有“第四次握手”会怎样？

如果客户端只收到 ServerHello，而没有最终的 Server Finished：

- 客户端不知道服务器是否成功处理密钥交换；
- 整个加密通道是不完整的；
- 会出现握手失败（握手阶段没有完成，浏览器可能提示“安全连接失败”）；
- 无法信任后续加密通信。

### ✅ 总结

| 步骤           | 作用                                           |
| -------------- | ---------------------------------------------- |
| 第一次握手     | 客户端发送ClientHello                          |
| 第二次握手     | 服务端返回ServerHello + Certificate等          |
| 第三次握手     | 客户端生成共享密钥、启动加密                   |
| **第四次握手** | **服务器确认密钥、完成握手，正式进入安全通信** |

## TLS1.3 （更快的 0-RTT/1-RTT 握手）

### ✅ 核心变化（对比 TLS 1.2）

| 项目            | TLS 1.2                  | TLS 1.3                       |
| --------------- | ------------------------ | ----------------------------- |
| 握手轮次（RTT） | 通常 2 个 RTT（4次交互） | 默认 1 个 RTT（2次交互）      |
| 明文传输内容    | ServerHello 等很多是明文 | 尽早加密，提升隐私性          |
| 密钥交换机制    | 支持 RSA、DH、ECDH 等    | 仅支持（EC）DHE，前向安全更强 |
| 加密套件数量    | 很多，协商复杂           | 精简，只有 5 个               |
| 0-RTT 支持      | ❌ 不支持                 | ✅ 支持 0-RTT（需恢复会话）    |
| 加密开始时间    | 第三次握手之后           | ServerHello 之后即可加密      |

------

### 🚀 TLS 1.3 握手流程（标准 1-RTT 情况）

```text
客户端                     服务端
  |------ ClientHello -------->|
  |                            |
  |<----- ServerHello ---------|
  |<----- EncryptedExtensions -|
  |<----- Certificate ----------|
  |<----- CertificateVerify ----|
  |<----- Finished -------------|
  |                            |
  |------ Finished ------------>|
```

**说明：**

- 客户端发送 `ClientHello`，内含：
  - 支持的加密算法、协议版本
  - 客户端生成的 key share（密钥协商的一部分）
- 服务端回复 `ServerHello` 之后：
  - 就可以立即开始加密通信（密钥已协商完成）
- 后续内容都 **已经加密**（不像 TLS 1.2）
- 客户端收到服务器的 `Finished` 后，也发送 `Finished`，握手完成。

------

### ⚡ TLS 1.3 的 0-RTT 握手（会话恢复）

TLS 1.3 支持“恢复上一次会话”的快速握手（0-RTT），适用于短时间内和同一个服务器通信。

```text
客户端                     服务端
  |---- ClientHello (0-RTT数据) -->|
  |                                |
  |<--------- Encrypted -----------|
  |<-------- Finished -------------|
  |                                |
  |-------- Finished ------------->|
```

- 客户端提前发出加密的 0-RTT 数据（缓存的会话密钥）
- 节省一个 RTT，提升首次字节到达速度
- ⚠️ 安全性略弱，不适合敏感数据（因为可能遭到重放攻击）

------

### ✅ 总结：TLS 1.3 的优势

| 优点                 | 说明                                         |
| -------------------- | -------------------------------------------- |
| 更快的握手           | 最少 1 个 RTT，支持 0-RTT 加速               |
| 更强的隐私保护       | 握手早期即进入加密状态，避免明文泄露         |
| 更简洁的加密套件选择 | 减少协商复杂性，默认使用前向安全密钥交换方式 |
| 向后兼容安全性高     | 移除不安全特性（如 RSA 密钥交换、静态 DH）   |

------

如果你之后准备面试，可以总结为一句话：

> **TLS 1.3 通过减少握手轮次、统一密钥交换机制、尽早启用加密通信等方式，提升了性能和安全性，并且支持 0-RTT 进一步加速已连接的服务。**

需要图示或者例题的话也可以告诉我！