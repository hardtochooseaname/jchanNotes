# GCC编译过程

************

## 1. 预编译

- 处理所有#开头的预处理指令，包括#include, #define, #if系列条件预编译指令等    

- 删除所有注释  

- 添加行号和文件名标识，比如`#2 "hello.c" 2`（第一个2表示行号为2，第二个2表示该信息由编译器产生），用于编译时产生错误或警告信息，也用于调试   

- 保留所有的#pragma编译器指令，这是特殊的预处理指令，常用于控制编译器的行为    

## 2. 编译

这是程序构建的核心部分，把预处理过后的文件，经过《编译原理》中的一系列分析和优化后，生成.s汇编代码文件。

1. 扫描（词法分析）  

2. 语法分析  

3. 语义分析  

4. 源代码优化  

5. 代码生成  

6. 目标代码优化（针对CPU硬件）

## 3. 汇编

    把汇编指令翻译成对应的机器指令，形成.o目标文件，有时候也成为”模块“  

## 4. 链接

#### 重定位 relocation

    在纸带和机器指令编程时代，假设在一个程序（纸带）内，有一条跳转指令”0001 0111“，8位的机器指令，高4位0001是跳转指令，低4位0111是跳转的目标地的绝对地址。那么，当修改文件的某些部分时，可能就会导致该跳转目的地的绝对地址发生改变，这时就需要对所有类似的跳转指令中的目标地址进行手动修改。这个重新计算绝对地址的过程就叫做重定位。  

    在后来（汇编、C语言出现），这个目的地可能是其他模块上的某个符号，而在编译当前模块时不知道目标符号的地址，这需要在后面链接的时候由链接器来修正该跳转指令中的绝对地址部分。这个地址修正也是重定位，每个要被修正的地方交做重定位入口(relocation entry)。

#### 符号 symbol

    由于机器指令编程相当繁琐与反人类，人们后来发明了汇编语言，开始使用一些符号和标记来帮助编程。其中，人们使用符号来代替难以使用的地址。到后来，”符号“就表示一个地址，可能是函数的入口地址，也可能是变量的起始地址，可以理解成物理地址的*别名*。在链接中，函数和变量就统称**符号**，函数名和变量名称作**符号名**。

#### 链接 link

    一个程序由多个模块组成，而各个模块之间的组合问题也就是模块之间如何通信的问题。最常见的模块间通信有两种形式：(a)模块间的函数调用，(b)模块间变量的访问。而这两种通信最重要的就是获取目标函数的入口地址或者目标变量的地址，也就是模块间符号的引用。而各个模块正是通过符号引用组合到一起，这个组合的过程就是链接。  

# 

# 目标文件

*********

## .bss段

    这是存放未初始化的全局变量和静态局部变量的段，这两种变量的一个共同点就是默认初始值为0，于是在.bss段中并没有存储实际的数据，仅仅在ELF的file header中的符号表中（`objdump -t <file.o>`）。而在内核把目标文件加载进内存并建立进程时，就会为进程分配相应的空间来存放数据，这时.bss段中的变量就会转移到数据段中，并且分配到所需存储空间，并将值初始化为0。

    所以，.bss段就是在目标文件中，为未初始化的全局变量和静态局部变量预留（运行时的）位置。

#### Location Trap

       由于.bss段的性质，如果一个全局变量或者静态局部变量的显式初始化值为0，那么某些编译器出于代码优化的考虑，把该变量放入.bss段而不是一个有初始值的变量应该在的数据段。  

### C++符号修饰与函数签名

        C++中有命名空间和函数重载的机制，可以方便地重复命名函数和变量。

        每个函数的函数名、参数列表、所在的类以及命名空间等其他信息，构成了一个用于唯一标识函数名的信息，即**函数签名**。

        而编译器和链接器在处理函数名是，会基于一些规则，根据函数签名中各项信息生成与函数一一对应的*修饰后名称*（decorated name），这就是**符号修饰**。变量也是如此，但是变量名的修饰并没有考虑到变量的类型，正如函数名的修饰也没有考虑函数的返回值。当然，不同编译器的修饰方法各不相同，这就意味着，不同编译器编译得到的目标文件并不能相互链接！！！

### 强符号与弱符号

       函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。符号的强弱是针对定义而不是引用而言的。

1. 不允许强符号被多次定义，即使在不同的目标文件中也不行。如果由同名强符号，编译器会报符号重复定义错误（multiple definition of ...）。

2. 若同名符号只有一个强符号，其他都是弱符号，选择强符号。

3. 若同名都是弱符号，则选择占用空间最大的弱符号。

## BFD库

    由于不同平台的软硬件基础不同，各平台所支持的目标文件格式也五花八门，这导致编译器和链接器很难处理目标文件的格式差异。于是为了解决这个跨平台的问题，GNU中出现了BFD项目，即在目标文件上多增加一层抽象，对上层掩盖目标文件的格式细节，提供统一的目标文件接口。

    同ELF文件格式一样，BFD的目标文件模型中，也有一个文件头，之后是各个段，每个段都有名字、属性和内容，同时还抽象了符号表、重定位表、字符串表等内容。

    现在gcc, ld, gdb和其他binutils工具都通过BFD来操作目标文件，而不是直接操作目标文件。这样即使需要采用一种新的目标文件格式，也只需要在BFD中添加一种格式即可，不需要修改编译器和链接器。

# 静态库

    静态库就是一个由多个目标文件打包构成的集合，对于C语言而言，开发环境所提供的C标准库中就包含了C语言静态库（在/usr/lib/libc.a）。在Linux中，多个目标文件通过ar压缩程序打包成一个.a的archive文件，这就是静态库。在编译时，将库中需要的目标文件链接过来，从而形成可执行文件。

    在C语言静态库中，每个函数都单独放在一个.o目标文件中的，比如printf在printf.o，malloc在malloc.o。这避免了链接的目标文件中含有程序不需要的内容，减少了最终链接成的可执行文件的大小。另外，库中的很多目标文件也调用了其他的库文件，所以往往程序链接的目标文件是比使用到的库函数要多。

    **但是**，这会导致使用了同一个目标文件的程序，都包含了该目标文件的副本（在可执行文件中），造成大量磁盘和内存空间的浪费。动态链接和动态库则解决了这个问题。

## 程序的入口函数：_start()

    C语言程序的入口函数不是main函数而是_start函数。_start()是有C语言静态库（libc.a）提供的，它通常由链接器ld调用，来初始化C程序的运行环境，进入main函数入口。在许多实现中它是汇编文件crt0.s，编译后在库中是目标文件crt0.o，每个程序在链接库文件的时候都会包含这个文件。它做的事情如下：  

1. Early low-level initialization, such as:
   1. Configuring **processor registers**
   2. Initializing external memory
   3. Enabling caches
   4. Configuring the [MMU](https://embeddedartistry.com/fieldmanual-terms/memory-management-unit/)
2. **Stack** initialization, making sure that the stack is properly aligned per the [ABI](https://embeddedartistry.com/fieldmanual-terms/application-binary-interface/) requirements
3. Frame pointer initialization
4. Initialization of the C/C++ runtime
5. Initialization of other scaffolding required by the system
6. **Jumping to `main`**
7. Exiting the program with the return code from `main`

# 链接

--------

链接的主要思路就是：相似段合并  

        相似段合并就是将每个目标文件中的.text  .data  .bss等段合并起来，成为可执行文件中的.text  .data  .bss等段。



静态链接使用的链接器是ld，而动态链接使用的则是另外的动态链接器

### 第一步：空间与地址分配

- 扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，再将对应段合并，得到新的段表    

- 将输入目标文件中的符号表中所有的符号定义和符号引用汇总起来，统一放到一个全局符号表中  

- 根据合并后各个段的长度和位置，分配虚拟地址空间，即每个段都会映射到一个VMA（virtual memory address 虚拟地址） 

<span style = "color:red">Note：在Linux下，ELF可执行文件默认从地址0x08048000开始分配</span>

### 第二步：符号解析与重定位

- 根据第一步中收集的信息，读取输入目标文件中段的数据、重定位信息，并且进行符号解析与重定位。这一步是链接过程的核心，尤其是重定位。

#### 重定位与重定位表

        **重定位**就是把目标文件中使用的虚拟地址转换成合并后的可执行文件中的虚拟地址。需要重定位的指令又分为两种：(1)绝对地址指令、(2)相对地址指令。

        由于在链接之前，目标文件中并没有分配虚拟地址空间，所以目标文件中的虚拟地址都是用的假的地址（绝对地址是0x0000、相对地址是非全零的假地址）替代的，然后在链接时通过重定位修改成正确的虚拟地址。

        **重定位表**是ELF文件中专门用来保存重定位信息的结构。实际上每一个需要重定位的段都有一个重定位表，而重定位表在ELF问价又是以段的形式存在的，所以也可说是一个个”重定位段“。

        每个需要重定位的地方都叫做*重定位入口（relocation entry）*，重定位入口的偏移表示入口在相应的需要重定位的段中的位置。

#### 符号解析

        在通常的观念中，之所以需要链接是因为目标文件中用到的某些符号定义在别的目标文件中，所以需要通过把目标文件都链接起来，进而找到那些符号的位置。

        重定位的时候，每个重定位入口都是对符号的引用。那么当链接器需要重定位确定某个符号引用指向的地址时，就需要在全局符号表中查找对应符号。

# 可执行文件的装载与进程

-----------

### 进程的建立

1. 创建一个独立的虚拟地址空间。即分配一个物理页用于创建一个空的根页表。  

2. 读取可执行文件头，建立虚拟空间与可执行文件的映射关系。即创建VMA(virtual memory area 虚拟内存空间)数据结构，记录每块虚拟地址空间分别与可执行文件中哪段对应。从而可以在虚拟空间中缺页时，知道应该从可执行文件中的哪一段的哪一部分读入相应页到内存。  

3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。

        由此可见，进程的创建并没有把整个ELF文件都装载进内存，主要做的就是两层映射：(1)虚拟地址/页到物理地址/页框的映射，这是偏底层的；(2)虚拟地址空间到可执行文件的映射，主要是通过VMA完成的，这一步决定了程序的各个段在虚拟空间是是如何分布，例如正文段、数据段分别在虚拟地址空间中哪一部分。

        这两层映射并不是上下层关系，(1)是为了实现虚拟地址到物理地址的转换，属于是“虚拟地址”这一块的功能，(2)是确定ELF文件各段在虚拟地址空间中的分布，属于是“装载”的基础，如果没有采用虚拟地址，那么这一部分完成的就是ELF各段与物理地址空间的映射。

### 动态装载&延迟加载

        从进程的创建过程可以看出，在进程创建时只有ELF文件头和程序头表（实际上以段的形式存在于ELF文件中，用于创建VMA）。而进程的其他段只是在进程创建的步骤2.中完成了到虚拟地址空间中的映射，实际的加载是在进程运行时，通过缺页中断装载进内存中的。

        要分清楚**动态装载**和**动态链接**的区别！

### VMA（virtual memory area）

        VMA除了用来映射可执行文件中的segment之外，还用用于管理进程虚拟地址空间中除了ELF文件的segment之外的部分，例如栈和堆。总之，VMA就是操作系统用来管理进程虚拟空间的最重要工具，所以虚拟空间中有的东西，VMA都要管。

        像堆和栈这种没有在文件中的映射，只是存在于进程空间（内存）中的VMA区域，就叫做*匿名虚拟内存区域*。

**VMA的实际结构：**

![](..\images\2023-10-18-11-25-27-CamScanner%2010-18-2023%2011.22.jpg)

### 链接视图的section和执行视图的segment

- **执行视图（Segment）**：ELF文件的segment视图是从可执行文件加载到内存并在运行时执行的角度来描述的。每个segment定义了可执行文件在内存中的一个区域，包括代码段、数据段、堆、栈等。这个视图更关注的是可执行文件如何在内存中加载和运行。

- **链接视图（Section）**：ELF文件的section视图是从编译和链接器的角度来描述的，关注的是源代码如何分割成不同的段和节，以及它们如何与链接器的符号表交互。这个视图更关注的是ELF文件的内部组织、连接和调试信息。

    链接视图和执行视图是在ELF文件中用于不同目的的两种不同的抽象。链接视图用于编译和链接过程，有助于组织和处理源代码，生成可执行文件。执行视图用于操作系统在运行时加载可执行文件，决定如何将不同的段映射到内存。

    所以，ELF文件的segment和section提供了两种不同的视图，每个视图都有自己的目的和用途，分别是链接视图和执行视图。这些视图共同构成了ELF文件的完整描述。

**关于链接和装载时的两次虚拟地址划分**

        看起来在链接时对section进行虚拟地址的划分似乎会多余。实际上，在ELF文件的处理过程中，section和segment的虚拟地址划分有各自的目的和意义。

1. **Section 虚拟地址划分**：
   
   - 虽然在链接时对section进行虚拟地址划分，看起来仅仅是为了将代码和数据组织成更小的单元，但它仍然具有一些重要的作用。例如，它有助于编译器和链接器处理不同类型的数据，如只读数据、读写数据、可执行代码等，以便正确地处理链接、重定位和地址分配。
   - Section的虚拟地址划分还用于支持调试信息。调试器需要知道每个源文件和每个函数的虚拟地址范围，以便能够在程序崩溃或需要调试时正确地定位源代码位置。

2. **Segment 虚拟地址划分**：
   
   - Segment的虚拟地址划分则更多地关注可执行文件在内存中的布局，以便操作系统正确地加载和运行程序。Segment将相关的section组合在一起，以便在装载时更高效地映射到内存中。
   - Segment的虚拟地址划分也允许在链接时进行一些优化，如代码段和数据段的合并，减少加载时的开销。

总的来说，section虚拟地址划分和segment虚拟地址划分在ELF文件处理过程中各有不同的作用和关注点。它们的协作有助于编译器、链接器和操作系统在不同层面和不同环节正确处理可执行文件。尽管在链接时进行section虚拟地址划分后，最终会在装载时将它们映射为segment，但这两个过程的分离仍然有其用途，帮助确保程序的正确性和性能。
