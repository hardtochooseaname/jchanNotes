### 库和头文件的关系
&emsp;&emsp;库和头文件之间存在一种依赖关系。

&emsp;&emsp;库（Library）是已经编译好的二进制文件，其中包含了预先编写好的函数和数据结构的实现。库可以包含函数、类、变量等，提供了特定功能的代码集合。库分为静态库（Static Library）和动态库（Dynamic Library）。静态库在编译时被链接到目标程序中，而动态库在运行时被加载到内存中。

&emsp;&emsp;头文件（Header File）包含了函数和数据结构的声明和定义，通常以`.h`为扩展名。头文件中定义了函数的原型、宏、结构体、枚举等。头文件是用来告诉编译器和链接器有关函数和数据结构的信息，以便在编译和链接过程中正确地使用库中的功能。

&emsp;&emsp;在使用库时，需要包含相应的头文件，以便编译器在编译过程中能够正确解析函数和数据结构的声明。头文件相当于一个接口，提供了对库中函数和数据结构的访问方式。通过包含头文件，可以在代码中调用库中定义的函数、使用库中定义的数据结构等。

&emsp;&emsp;简而言之，头文件是用来提供库中函数和数据结构的声明，而库则是已经编译好的二进制文件，包含了具体实现。头文件告诉编译器如何使用库中的功能，以便在编译和链接过程中能够正确使用库。

<br/>

### 编译和链接
&emsp;&emsp;在.c文件中，当需要使用一些别处的函数或者数据结构时，需要使用预处理指令#include，将声明这些函数或数据结构的头文件包括进来。（在学习C语言函数这一节时就了解到：在某处使用一个函数时，要么这个这个函数定义在前面，要么在前面有这个函数原型的声明）   

&emsp;&emsp;在编译过程中，编译器将会对每个源文件进行独立的编译，将源文件编译为中间目标文件（如.o文件）。同时，对于出现的函数调用，编译器会检查两点：有没有函数的声明或者原型（不会检查函数的定义）、函数调用的参数类型和返回值类型是否正确。    

&emsp;&emsp;然后在链接阶段，链接器会将所有的中间目标文件以及需要的库文件进行链接（在源文件中include的，其实只是库的头文件，而库中函数的具体实现全都在库文件本身，所以include了的头文件都还需要链接对应的库），生成最终的可执行文件。链接器会根据函数的引用和定义来解析符号并进行符号解析，将函数的定义与引用进行匹配。 

&emsp;&emsp;对于标准库，编译器通常会自动链接相应的库。但是对于其他库，需要在编译时通过指定链接选项（如-l）告诉编译器需要链接的库的名称。这样编译器才能找到对应的库文件并将其链接到最终的可执行文件中。

&emsp;&emsp;总结起来，编译和链接是构建一个可执行文件的两个关键步骤，其中编译将源代码编译成中间目标文件，链接将中间目标文件和所需的库文件进行链接生成最终的可执行文件。在编译过程中，头文件用于提供函数的声明和结构体的定义，但需要在链接阶段指定需要链接的库。  

#### 关于对函数的处理
&emsp;&emsp;在编译过程中，当一个源文件中的函数被调用或使用时，编译器只知道函数的声明或原型，但并不知道函数的具体定义和实现。编译器会将这个调用或使用处生成一个对函数的引用（也称为符号引用）。  
&emsp;&emsp;链接器是在编译过程的最后一步，它的主要任务是将多个编译后的目标文件（如.o文件）合并为一个可执行文件。在这个过程中，链接器会根据函数的引用和定义来解析符号并进行符号解析，将函数的定义与引用进行匹配。  
&emsp;&emsp;具体来说，链接器会检查所有编译后的目标文件，找到函数的定义。如果有多个目标文件中包含同名函数的定义，链接器会选择其中一个作为函数的定义，通常是在优先级最高的目标文件中找到的定义。  
&emsp;&emsp;一旦链接器找到了函数的定义，它会将函数的引用指向这个定义的地址，建立函数的关联关系。这样，在程序执行过程中，当遇到对函数的调用或使用时，实际上是通过这个关联关系来执行对应的函数定义。总结起来，链接器的任务是将函数的引用和定义进行匹配，确保在程序执行时可以正确地调用和执行函数的定义。
`/*赶紧他妈去学编译原理*/`

#### 关于库的名称
&emsp;&emsp;在使用 `-l` 选项指定库时，应该只提供库的基本名称，而不是完整的库文件名或包名称。
&emsp;&emsp;对于 `libreadline-dev` 库，其基本名称是 `readline`。所以在使用 `-l` 选项时，应该写 `-lreadline`。

&emsp;&emsp;在大多数情况下，库的基本名称是去除 `lib` 前缀和 `.a`（对于静态库）或 `.so`（对于动态库）后缀的部分。例如，对于库文件 `libreadline.so`，基本名称是 `readline`。
&emsp;&emsp;然而，有些库的基本名称可能不符合这个规则，所以最好的方法是查看库文件的实际名称或者查阅相关文档。你可以使用 `ls` 命令来查看库文件的名称。
&emsp;&emsp;例如，对于 `libreadline-dev` 库，可以使用以下命令来查看库文件的名称：

> `ls /usr/lib/x86_64-linux-gnu/libreadline.so*`

&emsp;&emsp;上述命令将列出与 `libreadline.so` 相关的文件。你可以根据列出的结果来确定库的基本名称。

<br/>

### 编译、链接与构建
&emsp;&emsp;构建是软件开发中一个广义的概念，它涵盖了多个步骤和操作，以生成可执行文件、库文件或其他软件组件。构建的目标是将源代码转换为可运行的软件，同时包括了编译、链接以及其他必要的处理过程。

&emsp;以下是构建过程中可能涉及的一些操作：

1. 源代码管理（Source Code Management）：
&emsp;&emsp;构建通常从源代码开始。源代码管理工具（如Git、SVN）用于跟踪和管理源代码的版本控制，确保团队成员可以协同开发和维护代码。

2. 依赖管理（Dependency Management）：
&emsp;&emsp;在构建过程中，软件通常依赖于其他库、框架或组件。依赖管理工具（如Maven、Gradle、npm）用于管理和解析这些依赖关系，以便在构建过程中自动下载和包含所需的依赖项。

3. 构建配置（Build Configuration）：
&emsp;&emsp;构建配置包括设置构建环境和参数，例如编译器选项、路径设置、预处理指令等。构建配置文件（如Makefile、CMakeLists.txt）用于定义这些配置，并指导构建工具执行相应的操作。

4. 编译（Compile）：
&emsp;&emsp;编译是将源代码文件（通常是以高级编程语言编写的）转换为目标代码（通常是**机器语言**或字节码）的过程。编译器会将源代码逐行解析，并将其转换为等效的目标代码表示形式，以便计算机可以理解和执行。编译的输出是目标文件（如目标机器代码、字节码或中间表示形式），它仍然需要进一步的处理才能生成可执行文件或库文件。

5. 链接（Link）：
&emsp;&emsp;链接是将目标文件和库文件组合成最终的可执行文件或库文件的过程。在编译过程中，源代码文件经过编译生成目标文件。然后，链接器将这些目标文件与所需的库文件进行合并，**解析它们之间的符号引用和跳转关系，并创建可执行文件或库文件**。链接的输出是一个独立的、可以直接执行的程序或一个可供其他程序使用的库文件。

6. 测试（Testing）：
&emsp;&emsp;构建过程通常涉及自动化测试，用于验证软件的正确性和稳定性。测试框架和工具（如JUnit、pytest）用于编写和执行单元测试、集成测试和系统测试，以确保构建的软件在各种场景下都能正确运行。

7. 打包和部署（Packaging and Deployment）：
&emsp;&emsp;构建完成后，软件可能需要打包成可分发的形式，如安装包、容器镜像等。打包工具（如dpkg、RPM、Docker）用于将构建生成的文件打包，并将软件部署到目标环境中。

&emsp;&emsp;简单来说，构建是包含了编译和链接过程的一个更为复杂的将源文件转换成可执行文件的操作。构建的对象通常是一些包含了众多源文件、使用了大量依赖库的复杂项目，构建过程通常根据项目的需求和工具的选择而有所不同。而Make和CMake都属于是构建工具，通过合理地管理和执行构建过程，可以提高软件开发的效率、质量和可维护性。

<br/>

### Make & CMake
&emsp;&emsp;Make和CMake都是构建工具，用于自动化软件项目的构建过程，但它们有一些区别和不同的使用方式。

Make：
- Make是一个非常古老和常用的构建工具，最初用于构建Unix系统上的C语言项目，现在也支持其他编程语言和其他操作系统。
- Make使用Makefile作为构建规则的定义文件，换句话说，当写好Makefile文件后，只需要执行个make命令，项目就会自动按照Makefile中的规则构建好。Makefile中包含了目标、依赖关系和构建命令的规则。但是Makefile文件需要用户根据项目的需求自行编写，由于Makefile的语法相对比较复杂，所以有一定的使用难度。
- Make基于目标和依赖关系，通过比较文件的修改时间来确定哪些文件需要重新构建，从而实现增量构建的效果。

CMake：
- CMake是一个跨平台的构建工具，它通过生成与平台相关的构建脚本（如Makefile、Visual Studio项目文件等）来实现跨平台构建的能力。
- CMake使用CMakeLists.txt文件作为构建规则的定义文件。CMakeLists.txt文件中包含了项目的设置、目标、依赖关系和构建命令等信息。CMake具有更简洁和易读的语法，使得构建规则的编写相对容易，并且提供了许多高级功能，如自动查找依赖库、条件构建等。
- CMake的主要目标是提供一个统一的构建系统，可以在不同的平台和编译器上生成相应的构建文件，从而使项目能够跨平台构建。

关系：
- Make是一个**构建工具**，依赖的是构建脚本Makefile。而在一定程度上，CMake就是一个**生成构建脚本的工具**，它生成构建脚本又依赖的是CMakeLists.txt。也就是说，可以使用更简单的CMake语法编写CMakeLists.txt文件，再将其输出成Makefile文件，进而使用make来构建项目。
- CMake还支持生成其他构建系统的脚本，如Visual Studio项目文件、Ninja构建文件等，这样您可以选择适合您的项目的构建系统。



### CMake的入门使用
以一个简单的项目为例，下面是项目的目录结构：
```css
project/
├── CMakeLists.txt
├── src/
│   ├── main.c
│   └── function.c
└── include/
    └── function.h
```
下面是CMakeLists.txt文件的内容（前三项是必须的）：
```cmake
# 在每个项目的顶层CMakeLists.txt中必须以该命令开头
# 说明项目构建所需要的cmake版本最低是多少，便于之后的CMake命令可以正常执行
cmake_minimum_required(VERSION 3.12)

# 指定项目名称MyProject，可以附加项目所用语言、项目版本等信息
project(MyProject)

# 指明需要编译和链接在一起的源文件，以及最终需要生成的可执行文件myapp
add_executable(myapp src/main.c src/function.c)

# 添加头文件搜索路径
target_include_directories(myapp PUBLIC include)

# 添加需要链接的第三方库readline（因为标准库如果用到了通常会默认链接）
target_link_libraries(myapp readline)

```

CMake的官方tutorial：https://cmake.org/cmake/help/latest/guide/tutorial/index.html
