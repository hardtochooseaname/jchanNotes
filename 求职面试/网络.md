# HTTP/2 笔记

## 1. 基本概念

- **Frame（帧）**
   HTTP/2的最小传输单位。每个帧都有固定的9字节帧头，其中包含：
  - 长度（3字节）：帧负载的字节数
  - 类型（1字节）：例如HEADERS、DATA、CONTINUATION等
  - 标志（1字节）：描述帧的属性，如END_STREAM、END_HEADERS等
  - 流标识符（4字节）：标识该帧所属的stream
- **Stream（流）**
   一个逻辑通道，用于承载一个完整的HTTP请求-响应交互。每个stream由唯一的stream ID标识。
  - 客户端主动创建的stream使用奇数ID
  - 服务器主动创建（如Server Push）的stream使用偶数ID
     流的作用包括实现多路复用和流量控制。
- **Message（消息）**
   HTTP请求或响应的逻辑单位。一个HTTP/2 message由：
  - 一个HEADERS帧（包含请求或响应头部）
  - 0个或多个DATA帧（包含请求或响应体）
     组成。每个stream内对应一条完整的请求和一条完整的响应消息。

## 2. 多路复用与帧交错传输

- **多路复用**
   HTTP/2允许在单一TCP连接上并发传输多个HTTP请求/响应，每个请求-响应对通过不同的stream来标识。
- **帧交错传输**
   各个stream内的帧可以交错发送。由于每个帧都带有stream ID，接收端能根据ID将不同stream的帧重新组装成各自的message。

## 3. HTTP/2与HTTP/1.1的对比

- **协议格式**
  - HTTP/1.1：基于文本，报文的请求行、头部以及分块传输编码（Chunked Transfer Encoding）都是文本格式，便于调试，但存在解析效率较低、队头阻塞问题。
  - HTTP/2：使用二进制帧格式，所有传输的数据（包括头部和body）均以二进制形式封装，带来更高效的解析和扩展性。
- **传输方式**
  - HTTP/1.1：一次请求-响应过程中通常按整个报文传输，动态内容可能使用分块传输编码。
  - HTTP/2：将报文拆分成多个帧进行传输，帧作为逻辑单元传输，接收端根据stream ID和帧结构重组完整消息。
- **多路复用**
  - HTTP/1.1的Pipeline只能在单个TCP连接内串行处理，存在队头阻塞问题。
  - HTTP/2在一个TCP连接上真正实现了多路复用，不同stream的帧可以交错发送，达到高并发传输效果。

## 4. 编码与分块

- **HTTP/1.1分块传输编码**
  - 服务器在无法预知完整内容长度时采用Chunked Transfer Encoding。
  - 每个chunk以文本形式描述长度（十六进制数字），后跟数据和换行符，然后一个大小为0的chunk标识结束。
- **HTTP/2二进制帧传输**
  - HTTP/2采用二进制分帧，将所有数据拆分为结构化的、固定格式的帧。
  - 这是一种应用层逻辑上的划分，与TCP分段无关。TCP仍然根据MSS等参数对HTTP/2帧进行分段传输。
- **分层设计**
  - HTTP/2帧是应用层结构，旨在实现流量控制、多路复用和优先级管理；而TCP分段是物理传输层对数据流的分割。两者各司其职，HTTP/2不需要按照TCP的分段来设计帧大小。

## 5. Server Push 与 Stream ID规则

- **Server Push**
   服务器可以主动推送资源，其创建的stream ID必须为偶数。
- **请求-响应对**
   客户端发起请求时创建stream（使用奇数ID），响应包括该stream内的HEADERS和DATA帧。
- **区分原则**
   每个stream只承载一条完整的请求及其对应的响应，避免混淆；各个stream可以并发交错传输，接收端根据stream ID组装成各自的message。

## 6. 关键点总结

- 一个HTTP请求在HTTP/2中只会有一个对应的响应，每个stream承载一个完整的请求-响应交互。
- HTTP/2的并发依赖于在单一TCP连接内按流（stream）分割和交错传输多个帧，每个帧通过stream ID标识归属。
- HTTP/2的帧结构化和二进制格式设计使得数据传输更高效，支持多路复用和流量控制，而这与TCP的分段传输互不干扰，各自处理不同层次的问题。

这份笔记涵盖了HTTP/2的核心架构、流、消息、帧等概念及其与HTTP/1.1的主要区别，有助于你在面试中条理清晰地回答相关问题。





# HTTPS

## 四次握手的必要性

虽然我们通常说 **TCP 三次握手**，但在 **TLS 建立安全连接的过程中**，确实可以被理解为类似“四次握手”的结构。下面我们明确一下这个“四次”的含义，特别是**“第四次握手是否必要”**的问题。

### 一、TLS（以 TLS 1.2 为例）的“握手流程”

下面是 TLS 1.2 的典型握手步骤，可以大致归纳为“类四次握手”：

1. **ClientHello（客户端发起）**
   - 包括支持的协议版本、随机数、加密套件列表等
2. **ServerHello + Certificate + ServerKeyExchange + ServerHelloDone（服务器响应）**
   - 确定加密参数，发送证书（含公钥）
3. **ClientKeyExchange + ChangeCipherSpec + Finished（客户端发送）**
   - 客户端生成对称加密密钥（Pre-Master Secret），加密后发给服务器
   - 发送ChangeCipherSpec：表示后续通信启用加密
   - 发送Finished：用密钥加密的摘要，验证握手是否成功
4. **ChangeCipherSpec + Finished（服务器确认）**
   - 服务器也开始使用加密通信
   - 发送Finished：表示握手完成

### 二、为什么是“四次”而不是“两次”或“三次”？

可以理解为“两次往返 RTT”：

- 第一次 RTT：客户端 -> 服务端
  - ClientHello
  - ServerHello + Certificate + ServerKeyExchange + ServerHelloDone
- 第二次 RTT：客户端 -> 服务端（ClientKeyExchange） -> 客户端
  - 客户端发送 key，表示开始加密通信
  - 服务器也确认，握手完成

这“第二个RTT”包含两个方向的消息，合起来就是 **“第四次握手”**。

### 三、第四次握手（Server Finished）是否必要？

**非常必要。原因如下：**

1. ✅ **安全性校验**
   - Server Finished 包含对之前所有握手内容的加密摘要（HMAC），客户端必须验证它来确认中间过程没有被篡改。
2. ✅ **确保服务器也完成了加密设置**
   - 如果没有 Server Finished，客户端无法确定服务器是否成功切换到了加密通信。
3. ✅ **防止中间人攻击**
   - 若跳过 Server Finished，中间人可能劫持后续通信而不被发现。

### 四、如果没有“第四次握手”会怎样？

如果客户端只收到 ServerHello，而没有最终的 Server Finished：

- 客户端不知道服务器是否成功处理密钥交换；
- 整个加密通道是不完整的；
- 会出现握手失败（握手阶段没有完成，浏览器可能提示“安全连接失败”）；
- 无法信任后续加密通信。

### ✅ 总结

| 步骤           | 作用                                           |
| -------------- | ---------------------------------------------- |
| 第一次握手     | 客户端发送ClientHello                          |
| 第二次握手     | 服务端返回ServerHello + Certificate等          |
| 第三次握手     | 客户端生成共享密钥、启动加密                   |
| **第四次握手** | **服务器确认密钥、完成握手，正式进入安全通信** |

## TLS1.3 （更快的 0-RTT/1-RTT 握手）

### ✅ 核心变化（对比 TLS 1.2）

| 项目            | TLS 1.2                  | TLS 1.3                       |
| --------------- | ------------------------ | ----------------------------- |
| 握手轮次（RTT） | 通常 2 个 RTT（4次交互） | 默认 1 个 RTT（2次交互）      |
| 明文传输内容    | ServerHello 等很多是明文 | 尽早加密，提升隐私性          |
| 密钥交换机制    | 支持 RSA、DH、ECDH 等    | 仅支持（EC）DHE，前向安全更强 |
| 加密套件数量    | 很多，协商复杂           | 精简，只有 5 个               |
| 0-RTT 支持      | ❌ 不支持                 | ✅ 支持 0-RTT（需恢复会话）    |
| 加密开始时间    | 第三次握手之后           | ServerHello 之后即可加密      |

------

### 🚀 TLS 1.3 握手流程（标准 1-RTT 情况）

```text
客户端                     服务端
  |------ ClientHello -------->|
  |                            |
  |<----- ServerHello ---------|
  |<----- EncryptedExtensions -|
  |<----- Certificate ----------|
  |<----- CertificateVerify ----|
  |<----- Finished -------------|
  |                            |
  |------ Finished ------------>|
```

**说明：**

- 客户端发送 `ClientHello`，内含：
  - 支持的加密算法、协议版本
  - 客户端生成的 key share（密钥协商的一部分）
- 服务端回复 `ServerHello` 之后：
  - 就可以立即开始加密通信（密钥已协商完成）
- 后续内容都 **已经加密**（不像 TLS 1.2）
- 客户端收到服务器的 `Finished` 后，也发送 `Finished`，握手完成。

------

### ⚡ TLS 1.3 的 0-RTT 握手（会话恢复）

TLS 1.3 支持“恢复上一次会话”的快速握手（0-RTT），适用于短时间内和同一个服务器通信。

```text
客户端                     服务端
  |---- ClientHello (0-RTT数据) -->|
  |                                |
  |<--------- Encrypted -----------|
  |<-------- Finished -------------|
  |                                |
  |-------- Finished ------------->|
```

- 客户端提前发出加密的 0-RTT 数据（缓存的会话密钥）
- 节省一个 RTT，提升首次字节到达速度
- ⚠️ 安全性略弱，不适合敏感数据（因为可能遭到重放攻击）

------

### ✅ 总结：TLS 1.3 的优势

| 优点                 | 说明                                         |
| -------------------- | -------------------------------------------- |
| 更快的握手           | 最少 1 个 RTT，支持 0-RTT 加速               |
| 更强的隐私保护       | 握手早期即进入加密状态，避免明文泄露         |
| 更简洁的加密套件选择 | 减少协商复杂性，默认使用前向安全密钥交换方式 |
| 向后兼容安全性高     | 移除不安全特性（如 RSA 密钥交换、静态 DH）   |

------

如果你之后准备面试，可以总结为一句话：

> **TLS 1.3 通过减少握手轮次、统一密钥交换机制、尽早启用加密通信等方式，提升了性能和安全性，并且支持 0-RTT 进一步加速已连接的服务。**

需要图示或者例题的话也可以告诉我！





# TCP

## 如何理解TCP是基于字节流的传输层通信协议？

简单来说，“基于字节流的通信协议”意味着 TCP 把应用程序发送的数据视为一个无结构的、连续的字节序列，而不会保留应用程序写入数据时的“消息”边界。

对于HTTP/2而言，一个TCP报文中就可以包含多个比较小的帧，而TCP并不知道它这个报文中传输的是几个帧的数据，只知道它传输了多少个字节的数据，也不不知道每个帧的边界。每个帧的边界还要靠应用层中网络栈中接收到数据后自己来划分。

你可以想象一个水管：

- **应用程序** 把数据写入这个水管（就像把水倒进去）。你可以一次倒一瓢水（一个 `send()` 调用），也可以一次倒一杯水（另一个 `send()` 调用）。
- **TCP** 在水管里传输的只是**连续不断的水流（字节流）**。它会根据需要（比如考虑到网络的拥塞状况、接收方的窗口大小、单个报文段的最大长度等）将水流切割成一块一块的（**TCP 报文段**）进行传输。
- **接收方的 TCP** 收到这些水块（报文段）后，会把它们按照顺序重新组合起来，**再汇聚成一个连续的水流**。
- **接收方的应用程序** 从这个水管的另一端读取水流（使用 `read()` 或 `recv()` 调用）。它可以一次读一小口水，也可以一次读一大口水。

### 关键点

- TCP 视角下它传输的数据仅仅是字节流
- TCP 的可靠性保证也是字节流，确保的是字节流能够无丢失、无重复、按顺序地正确传输到接收端



# UDP

## UPD 与 TCP 的区别

要点较多，可以从TCP的三个定语出发：

#### 面向连接的

1. 连接

    TCP 是面向连接的传输层协议，传输数据前先要建立连接。 UDP 是不需要连接，即刻传输数据。

2. 服务对象

   TCP 是一对一的两点服务，即一条连接只有两个端点。 UDP 支持一对一、一对多、多对多的交互通信

#### 可靠的

3. 可靠性TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。 UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输

4. 拥塞控制、流量控制

   TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

#### 基于字节流的

5. 传输方式

   TCP 是流式传输，没有边界，但保证顺序和可靠。 UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。 

6. 分片不同

   TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。 UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层.

---

7. 首部开销 TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。 UDP 首部只有 8 个字节，并且是固定不变的，开销较小。