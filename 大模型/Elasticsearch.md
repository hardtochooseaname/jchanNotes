# Elasticsearch 

Elasticsearch 是一个**基于全文搜索引擎 Lucene 的开源分布式搜索引擎**，广泛用于日志分析、搜索推荐、数据分析等场景。它不仅能进行全文检索，还能处理结构化数据、地理位置数据和时间序列数据。

------

## 🌟 一句话解释

> Elasticsearch 是一个可以快速、实时地对大量结构化或非结构化数据进行搜索、分析的分布式搜索引擎。

## 核心功能

| 功能         | 说明                                       |
| ------------ | ------------------------------------------ |
| 🔍 全文搜索   | 能对自然语言文本进行模糊、匹配、短语搜索等 |
| 📦 分布式存储 | 自动切分数据、分片、副本，天然支持横向扩展 |
| 📊 实时分析   | 聚合分析（如分组、求平均、排序）速度非常快 |
| 🔄 REST API   | 所有功能可通过 HTTP/JSON 接口调用          |
| 📚 强大的索引 | 支持倒排索引、字段分析、分词、布尔查询等   |

## Elasticsearch 工作原理简图

1. **写入数据**：
   - 数据被写入某个「索引（index）」，相当于数据库。
   - 每条数据是一个「文档（document）」，是 JSON 格式的。
2. **索引过程**：
   - 文档会被「倒排索引」处理，支持快速全文搜索。
   - 也会提取结构化字段用于过滤、排序等。
3. **搜索流程**：
   - 用户发起一个查询（Query DSL）。
   - 查询会分发到多个分片（Shards）上并行执行，最终合并结果返回。

## Elasticsearch 查询返回什么结果？

- **是一组排序好的文档序列**
- **排序依据就是 BM25 打分**
- BM25 会根据用户查询中的每个关键词在文档中出现的“重要性”进行评分
- **分数越高，表示该文档越可能是用户想要的**

## 和传统数据库的区别

| 项目     | Elasticsearch          | 传统关系型数据库 |
| -------- | ---------------------- | ---------------- |
| 数据结构 | JSON 文档              | 行和列（表）     |
| 搜索能力 | 全文检索 + 模糊匹配    | 精确匹配         |
| 扩展性   | 分布式天然支持         | 垂直扩展为主     |
| 查询语言 | Query DSL（类似 JSON） | SQL              |
| 主要用途 | 搜索 + 分析 + 日志     | 事务处理（OLTP） |

## 典型应用场景

- 🔍 **站内搜索引擎**（如电商、文档库）
- 📈 **日志分析**（常与 Logstash、Kibana 配合组成 ELK 堆栈）
- 👮‍♀️ **安全审计 / 异常检测**
- 🧠 **推荐系统**（基于搜索相似内容）
- ⏱️ **实时指标聚合和报表**

## Elasticsearch 常和哪些工具配合？

- **Logstash**：日志采集和处理管道
- **Beats**：轻量级日志采集器
- **Kibana**：可视化工具（图表 + 仪表盘）
- ➡️ 合称为 **ELK 或 Elastic Stack**

## BM25 的打分逻辑简化理解：

> “一个关键词在某文档中出现得多，且这个关键词不常见，且文档不太长” → 那这个文档更重要

所以它综合考虑了：

| 因素           | 影响作用                               |
| -------------- | -------------------------------------- |
| 词频 TF        | 出现越多越重要，但会饱和               |
| IDF            | 稀有词权重更高（更有区分度）           |
| 文档长度调整项 | 长文档有惩罚，避免长文“自然包含”太多词 |







# 倒排索引

Elasticsearch 使用的是一种叫 **倒排索引（Inverted Index）** 的结构，它的核心思想就是：

> **"提前为所有词建好一个查找表，查询时直接查表即可。"**

就像一本超快的图书馆卡片目录。

## 以关键词查询为例：

假设你有这样的 3 个文档：

```txt
Doc1: Steve Jobs founded Apple.
Doc2: Apple released iPhone.
Doc3: Jobs died in 2011.
```

Elasticsearch 会提前建立一个**倒排索引表**：

| 词      | 出现在哪些文档？（posting list） |
| ------- | -------------------------------- |
| steve   | Doc1                             |
| jobs    | Doc1, Doc3                       |
| apple   | Doc1, Doc2                       |
| founded | Doc1                             |
| iphone  | Doc2                             |
| died    | Doc3                             |
| 2011    | Doc3                             |

🔧 这个索引是提前构建并压缩优化过的（Lucene 支撑），所以查询 `apple` 的时候，系统只需要：

1. **哈希表查找 "apple" 这个词项**（≈O(1)）
2. **得到 posting list：Doc1, Doc2**
3. **对 Doc1、Doc2 打分排序（BM25）**，只需遍历 posting list，时间复杂度是 O(相关文档数量)



## 更专业一些地说：

Elasticsearch 查询的「理论时间复杂度」大致是：

```text
T(query) ≈ O(1) + O(n_doc_in_posting_list)
```

而不是 O(总文档数量)，这就是快的本质。

## 为了加速，它还用了哪些手段？

1. **词典前缀树 + FST 自动机**
   - 查询词拼写变形、模糊匹配都能很快搞定
2. **Lucene 倒排索引压缩 + 内存映射**
   - posting list 是磁盘和内存之间高效管理的，延迟极低
3. **skip list / block-max 优化**
   - 在 posting list 中可以快速跳过低相关性文档，加速 BM25 打分过程

## 为什么说是「近似 O(1)」而不是绝对 O(1)？

因为最终还是要：

- 查 posting list（不是定长的）
- 对 posting list 中的文档打分排序（相关文档越多越慢）

但是如果你的查询是冷门关键词（posting list 很短），查出来基本就是 O(1) 级别的速度。



# 倒排索引表

### ✅ **倒排索引的“词典”部分，本质上就像一个巨大的哈希表或树状结构**：

- 每个词（term）是 key
- key 对应的 value 是一个 **posting list**：也就是这个词在哪些文档中出现过

比如：

```json
{
  "apple": [doc1, doc2],
  "jobs": [doc1, doc3],
  "iphone": [doc2]
}
```

在 Elasticsearch（底层是 Lucene）里，这个查词典的操作可以非常快：

- 传统可以用 **哈希表**
- 实际上 Lucene 更常用 **前缀压缩 + 有限状态自动机（FST）**，可以做到更省内存并且查得也很快（接近 O(1)）

------

### 🔍 那么快的根本原因可以总结为两个方面：

#### **1. 查词典快**

> 词典结构查词基本是 O(1) 的（或近似），靠的就是哈希或 FST 优化。

#### **2. 查 posting list 是“只看一小部分文档”**

> 不用全局扫描，只查和关键词匹配的 posting list，通常非常短。

也就是说：

```text
时间复杂度 ≈ O(1) + O(相关文档数量)
```

这就比向量数据库那种「计算每个向量距离」或「做近似搜索」快得多。

------

### 💡 举个类比：

假设有 1 亿条文档：

- Elasticsearch：查词典哈希表 + 从 posting list 中选几十个文档 → 非常快
- 向量数据库：即便用 HNSW 等近似搜索，也要做多次向量距离计算 → 较慢

------

### ✅ 结论：你说的完全正确！

> 🔑 Elasticsearch 查询快，是因为**倒排索引表的词典部分就像哈希表**，查询一个词是否存在非常快；
>  再加上 posting list 的稀疏性和 Lucene 的工程优化，整个查询过程就近似 O(1)。



# Elasticsearch 的排序和评分

Elasticsearch 使用一种“打分机制”来评估某个文档和用户查询之间的相关性（relevance）。在默认配置下，它使用的是 **BM25** 算法，这是 TF-IDF 的改进版。

------

### 1. 🧮 TF-IDF 简介（基础打分算法）

TF-IDF 是「Term Frequency - Inverse Document Frequency」的缩写，意思是：

- **TF（词频）**：某个词在文档中出现的次数，出现越多代表越重要。
- **IDF（逆文档频率）**：这个词出现在越多文档中，信息量越低，需要“惩罚”。

#### ✏️ 计算公式（简化）：

```
TF-IDF(term, doc) = TF(term, doc) * log(N / DF(term))
```

- `N`：总文档数
- `DF(term)`：包含该词的文档数

------

### 2. 🔍 BM25（默认算法）

BM25 是 TF-IDF 的改良版本，它引入了文档长度的影响，并对词频进行了“饱和”处理（词出现太多次，不代表无限重要）。

#### 📘 BM25 的核心考虑：

- 如果一个词在某文档中多次出现：打分上升
- 但出现次数非常多：上升趋于饱和（不像 TF 那样无限增长）
- 文档太长：可能本来就容易包含很多词，因此整体得分要稍作“惩罚”

#### 🔢 BM25 公式（简化）：

```
Score = IDF(term) * [(TF * (k + 1)) / (TF + k * (1 - b + b * (doc_len / avg_doc_len)))]
```

- `k`、`b` 是可调参数（默认 k=1.2, b=0.75）
- `doc_len`：当前文档的长度
- `avg_doc_len`：所有文档的平均长度

> Elasticsearch 默认就是用 BM25 来对关键词搜索结果排序的。

------

### 📈 总结一下：

- Elasticsearch 查询的结果是排序的。
- 排序依据是 BM25 算法，它衡量用户关键词和文档之间的相关性。
- 可以自定义评分算法（例如使用 `function_score` 查询）