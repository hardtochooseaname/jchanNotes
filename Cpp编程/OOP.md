# 面向对象程序设计 - OOP

-----

## 继承

这是把相似类型的类联系在一起形成的**层次关系**

### 1. 基类（base class）

处于层次关系根部的类，拥有这些相似的类所共有的一些成员

访问说明符`protected`：介于public和private之间的访问权限，private成员是在基类外部以及派生类中都不能访问，而protected是在基类外部不能访问，但是派生类中可以访问。



### 2. 派生类（derived class）

从基类继承而来的类，定义了各自特有的成员

**派生类的定义**：派生列表

```cpp
class TaskProxy: public Task{
  ...  
};
```

派生列表即上面冒号后的**基类列表**`public Task`。实际上还可以列出多个基类，用逗号隔开，指明派生类继承自哪些基类。

**访问权限限定**：

- 上面派生列表中的`public`是**访问说明符**，表示派生类中继承自基类的public成员的访问权限依旧是public；

- 如果不加public，那么默认派生类继承自基类的public和protected成员都将是private，不能从派生类外部访问，相当于`private`；

- 而`protected`，使得基类的public成员在派生类中依旧是public，protected依旧是protected。



**派生类的声明**：和普通的类的声明一样，不需要也不能够加上派生列表。



**派生类对基类的初始化**：

        基类的初始化会在派生类初始化的时候进行。如果没有在派生类的构造函数中显式地对基类初始化，则会自动调用基类的默认构造函数进行默认初始化，然后再对派生类自己的部分进行初始化。

        对基类的显式初始化只能放在派生类构造函数的初始化列表中，因为构造函数进入函数体时，需要已经把基类部分初始化完成，在函数体中执行的仅仅是派生类自己的初始化。

```cpp
class Derived : public Base {
public:
    Derived(int value1, int value2) : Base(value1), value_(value2) {}
private:
    int value_;
};
```

### 3. 派生类向基类的转换

一个派生类对象，实际可以划分为为两部分：

- 继承自基类的部分（如果继承自多个基类，则会有多个基类部分）

- 派生类自己的部分

因此，C++中，**基类指针或引用既可以指向基类对象，也可以指向各个派生类对象**。当基类的指针和引用指向派生类对象时，实际指向的是其中的基类部分。而这一特性，是类的**多态**的基础。



<mark>Note</mark>：要在用户代码（类外代码）中使用派生类向基类的转换时，派生类对基类的继承必须是public的，只有这样派生类中的基类部分在用户代码中才是可访问的，才能有指针或引用指向它。



**资源释放 & 析构函数**：

当使用基类指针指向派生类对象时，delete这个指针，那么

1. 如果基类的析构函数不是虚函数，就只会调用基类的析构函数，delete也只会释放基类部分的内存空间，容易产生内存泄漏的问题

2. 如果基类的析构函数是虚函数，那么会调用派生类的析构函数，delete也释放派生类全部的内存

派生类的析构函数在被调用时，同样也会自动调用基类的析构函数，但是会先执行派生类本身的析构函数，与构造函数的调用顺序相反。



### 4. 虚函数

        基类中的所有成员函数可以分为两类：一种是可以在派生类中重写定义的、另一种是不允许在派生类中重写定义的。前者通过在**类内部的函数声明**前加上**virtual**关键字定义为虚函数。

        成员函数中，除了构造函数和静态函数之外的所有成员函数都可以定义为虚函数。



 动态绑定：

        动态绑定是在程序运行时，会临时根据基类的指针或引用指向的实际对象来决定调用哪个版本的虚函数定义。

        另外，可以通过域作用运算符来指定调用的虚函数版本。



重写虚函数定义：

          在派生类中override虚函数的时候，新的虚函数定义中形参列表和返回值类型必须保持不变！

override说明符：

        在派生类中可以定义与基类中的虚函数同名的其他函数（返回值或者形参列表不同），这就会导致当用户想要重写虚函数定义时，由于弄错形参列表或返回值类型，导致并没有真正覆盖虚函数定义（而是定义了一个新函数），而这一错误有时候很难排查。而加上override说明符则会提醒编译器这是重写的虚函数，从而让编译器检查函数类型是否一致，便于排查错误。

        override和virtual关键字一样，都必须放在类内声明中，不能放在类外。因为这两个关键字都是要在编译器尝试理解类的定义时，告诉编译器该函数是虚函数的覆盖/这是一个需要动态绑定的虚函数。



虚函数的默认实参：

        当通过基类的指针或引用调用虚函数时，不论动态绑定的是虚函数的哪个版本，函数使用的默认实参都会是基类中指定的默认实参。除非直接使用派生类的指针或引用来调用该虚函数。



**纯虚函数 & 抽象基类**：

        当基类的中只想有某个虚函数的声明而没有定义时，我们称这个基类只提供了这个虚函数的接口，而让派生类来提供虚函数的实现。这样的虚函数就是纯虚函数，通过在声明中加上`= 0`指定。

```cpp
class AbstractClass{
    virtual void pure() = 0;
}
```

        拥有纯虚函数的类，则称为抽象基类。而抽象基类不能实例化，因为通常抽象基类仅仅是为了设计的需要而存在的类，我们实际使用的都是其派生类，也因为缺少纯虚函数的函数定义。



Note：当要写纯虚函数的时候，不是说在基类中没有定义的就是纯虚函数！如果没有用`=0`告诉编译器这是一个纯虚函数，那么编译器就会在链接的时候寻找其定义，而找不到定义就会出错。

```
/usr/bin/ld: ... : undefined reference to `Buffer::send_(int)'
/usr/bin/ld: ... : undefined reference to `Buffer::recv_(int)'
```


